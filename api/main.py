"""
FastAPI Application for Vercel Deployment
Generated by vercel-fastapi-link skill v1.2.0

Project: Physical AI Book API
GitHub Pages: https://faiqahm.github.io
"""

import os
import logging
from datetime import datetime
from typing import Optional, List

from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field

# =============================================================================
# Logging Configuration
# =============================================================================
# Configure logging so agents can read Vercel logs for debugging
# Vercel captures stdout/stderr, so we use StreamHandler

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger("Physical AI Book API".lower().replace(" ", "-"))

# Adjust log level from environment (DEBUG, INFO, WARNING, ERROR)
log_level = os.getenv("LOG_LEVEL", "INFO").upper()
logger.setLevel(getattr(logging, log_level, logging.INFO))

# =============================================================================
# Pydantic Models - Define your request/response schemas here
# =============================================================================

class HealthResponse(BaseModel):
    """Health check response model."""
    status: str = Field(..., example="healthy")
    service: str = Field(..., example="physical-ai-book-api")
    timestamp: str = Field(..., example="2024-01-01T12:00:00Z")


class ChapterSummary(BaseModel):
    """Summary of a chapter for listing."""
    id: int = Field(..., example=1)
    title: str = Field(..., example="Introduction to Physical AI")
    slug: str = Field(..., example="intro")


class ChapterDetail(BaseModel):
    """Full chapter details."""
    id: int
    title: str
    content: str = Field(..., example="Chapter content goes here...")
    created_at: Optional[str] = None
    updated_at: Optional[str] = None


class ChapterListResponse(BaseModel):
    """Response model for chapter listing."""
    chapters: List[ChapterSummary]
    total: int = Field(..., example=3)


class ErrorResponse(BaseModel):
    """Standard error response model."""
    detail: str = Field(..., example="Resource not found")
    error_code: Optional[str] = Field(None, example="NOT_FOUND")


# =============================================================================
# App Configuration
# =============================================================================

app = FastAPI(
    title="Physical AI Book API",
    description="Backend API for the Physical AI Educational Book",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
)

logger.info("FastAPI application initialized")

# =============================================================================
# CORS Configuration - Allow GitHub Pages frontend
# =============================================================================

# Get GitHub Pages URL from environment or use default
GITHUB_PAGES_URL = os.getenv("GITHUB_PAGES_URL", "https://faiqahm.github.io")

# Base allowed origins
allowed_origins = [
    "http://localhost:3000",      # Local Docusaurus dev
    "http://localhost:8000",      # Local FastAPI dev
    "http://127.0.0.1:3000",
    "http://127.0.0.1:8000",
    GITHUB_PAGES_URL,             # Production GitHub Pages
    f"{GITHUB_PAGES_URL}/",       # With trailing slash
]

# Add extra origins from environment variable (comma-separated)
extra_origins_env = os.getenv("EXTRA_CORS_ORIGINS", "")
if extra_origins_env:
    for origin in extra_origins_env.split(","):
        origin = origin.strip()
        if origin and origin not in allowed_origins:
            allowed_origins.append(origin)

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
    allow_headers=["Authorization", "Content-Type", "Accept", "Origin"],
    max_age=600,
)

# =============================================================================
# Health Check Endpoint
# =============================================================================

@app.get("/health", response_model=HealthResponse)
async def health_check():
    """Health check endpoint for monitoring."""
    logger.debug("Health check requested")
    return HealthResponse(
        status="healthy",
        service="physical-ai-book-api",
        timestamp=datetime.utcnow().isoformat() + "Z",
    )


@app.get("/")
async def root():
    """Root endpoint with API info."""
    logger.info("Root endpoint accessed")
    return {
        "message": "Physical AI Book API",
        "docs": "/docs",
        "health": "/health",
    }

# =============================================================================
# API Routes - Add your endpoints below
# =============================================================================

@app.get("/api/ping")
async def ping():
    """Simple ping endpoint for testing connectivity."""
    logger.debug("Ping endpoint called")
    return {"message": "pong"}


@app.get("/api/v1/chapters", response_model=ChapterListResponse)
async def list_chapters():
    """List all available chapters."""
    logger.info("Listing all chapters")
    chapters = [
        ChapterSummary(id=1, title="Introduction to Physical AI", slug="intro"),
        ChapterSummary(id=2, title="Sensors and Perception", slug="chapter-1"),
        ChapterSummary(id=3, title="Actuators and Control", slug="chapter-2"),
    ]
    logger.debug(f"Returning {len(chapters)} chapters")
    return ChapterListResponse(chapters=chapters, total=len(chapters))


@app.get(
    "/api/v1/chapters/{chapter_id}",
    response_model=ChapterDetail,
    responses={404: {"model": ErrorResponse}},
)
async def get_chapter(chapter_id: int):
    """Get a specific chapter by ID."""
    logger.info(f"Fetching chapter with id={chapter_id}")

    chapters = {
        1: ChapterDetail(id=1, title="Introduction to Physical AI", content="..."),
        2: ChapterDetail(id=2, title="Sensors and Perception", content="..."),
        3: ChapterDetail(id=3, title="Actuators and Control", content="..."),
    }

    if chapter_id not in chapters:
        logger.warning(f"Chapter not found: id={chapter_id}")
        raise HTTPException(status_code=404, detail="Chapter not found")

    logger.debug(f"Returning chapter: {chapters[chapter_id].title}")
    return chapters[chapter_id]


# =============================================================================
# Error Handlers
# =============================================================================

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler for unhandled errors."""
    logger.error(f"Unhandled exception: {type(exc).__name__}: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error", "error_code": type(exc).__name__},
    )


# =============================================================================
# Vercel Serverless Handler
# =============================================================================

# The app object is automatically detected by @vercel/python
# No additional handler needed for Vercel deployment
